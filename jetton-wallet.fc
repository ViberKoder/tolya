#include "imports/stdlib.fc";
#include "imports/op-codes.fc";
#include "imports/jetton-params.fc";

;; Jetton 2.0 Wallet Contract
;; Storage scheme:
;; balance:Coins owner_address:MsgAddress jetton_master_address:MsgAddress jetton_wallet_code:^Cell

(int, slice, slice, cell) load_data() inline {
    slice ds = get_data().begin_parse();
    return (
        ds~load_coins(),        ;; balance
        ds~load_msg_addr(),     ;; owner_address
        ds~load_msg_addr(),     ;; jetton_master_address
        ds~load_ref()           ;; jetton_wallet_code
    );
}

() save_data(int balance, slice owner_address, slice jetton_master_address, cell jetton_wallet_code) impure inline {
    set_data(begin_cell()
        .store_coins(balance)
        .store_slice(owner_address)
        .store_slice(jetton_master_address)
        .store_ref(jetton_wallet_code)
        .end_cell()
    );
}

() send_tokens(slice in_msg_body, slice sender_address, int msg_value, int fwd_fee) impure {
    int query_id = in_msg_body~load_uint(64);
    int jetton_amount = in_msg_body~load_coins();
    slice to_owner_address = in_msg_body~load_msg_addr();
    
    (int balance, slice owner_address, slice jetton_master_address, cell jetton_wallet_code) = load_data();
    
    balance -= jetton_amount;
    
    throw_unless(705, equal_slices(owner_address, sender_address));
    throw_unless(706, balance >= 0);
    
    cell state_init = calculate_jetton_wallet_state_init(to_owner_address, jetton_master_address, jetton_wallet_code);
    slice to_wallet_address = calculate_jetton_wallet_address(state_init);
    
    slice response_address = in_msg_body~load_msg_addr();
    cell custom_payload = null();
    if (in_msg_body.slice_bits() > 0) {
        custom_payload = in_msg_body~load_dict();
    }
    int forward_ton_amount = in_msg_body~load_coins();
    
    slice either_forward_payload = in_msg_body;
    
    int fwd_count = forward_ton_amount ? 2 : 1;
    throw_unless(709, msg_value >
        forward_ton_amount +
        fwd_count * fwd_fee +
        (2 * 10000000 + 10000000)); ;; 3 * gas_consumption
    
    var msg_body = begin_cell()
        .store_uint(op::internal_transfer(), 32)
        .store_uint(query_id, 64)
        .store_coins(jetton_amount)
        .store_slice(owner_address)
        .store_slice(response_address)
        .store_coins(forward_ton_amount)
        .store_slice(either_forward_payload)
        .end_cell();
    
    var msg = begin_cell()
        .store_uint(0x18, 6)
        .store_slice(to_wallet_address)
        .store_coins(0)
        .store_uint(4 + 2 + 1, 1 + 4 + 4 + 64 + 32 + 1 + 1)
        .store_ref(state_init)
        .store_ref(msg_body);
    
    send_raw_message(msg.end_cell(), 64);
    
    save_data(balance, owner_address, jetton_master_address, jetton_wallet_code);
}

() receive_tokens(slice in_msg_body, slice sender_address, int my_ton_balance, int fwd_fee, int msg_value) impure {
    ;; NOTE we can not allow fails in action phase since in that case there will be
    ;; no bounce. Wallet owner will not be notified that transfer is failed (or will be notified only if the bounce message will be delivered successfully).
    ;; On the other hand, we can not simply accept tokens because that would be convenient way to attack (e.g. if forward_ton_amount is large enough (2^63 nanotons - `impossible` value), the wallet will accept tokens, will try to send notification, will fail, and the tokens will be lost).
    ;; In that case, we do not accept tokens at all, and will bounce them back if we can not send the notification.
    ;; This is allowed, because sender in this function is always a jetton wallet, and wallet code does not generate an exception on bounce.
    
    int query_id = in_msg_body~load_uint(64);
    int jetton_amount = in_msg_body~load_coins();
    (int balance, slice owner_address, slice jetton_master_address, cell jetton_wallet_code) = load_data();
    
    slice from_address = in_msg_body~load_msg_addr();
    slice response_address = in_msg_body~load_msg_addr();
    
    throw_unless(707,
        equal_slices(calculate_user_jetton_wallet_address(from_address, jetton_master_address, jetton_wallet_code), sender_address)
        |
        equal_slices(jetton_master_address, sender_address)
    );
    
    int forward_ton_amount = in_msg_body~load_coins();
    
    int ton_balance_before_msg = my_ton_balance - msg_value;
    int storage_fee = 10000000 - min(ton_balance_before_msg, 10000000);
    msg_value -= (storage_fee + 10000000);
    
    if (forward_ton_amount) {
        msg_value -= (forward_ton_amount + fwd_fee);
        
        slice either_forward_payload = in_msg_body;
        
        var msg_body = begin_cell()
            .store_uint(op::transfer_notification(), 32)
            .store_uint(query_id, 64)
            .store_coins(jetton_amount)
            .store_slice(from_address)
            .store_slice(either_forward_payload)
            .end_cell();
        
        var msg = begin_cell()
            .store_uint(0x10, 6)
            .store_slice(owner_address)
            .store_coins(forward_ton_amount)
            .store_uint(1, 1 + 4 + 4 + 64 + 32 + 1 + 1)
            .store_ref(msg_body);
        
        send_raw_message(msg.end_cell(), 1);
    }
    
    if ((response_address.preload_uint(2) != 0) & (msg_value > 0)) {
        var msg = begin_cell()
            .store_uint(0x10, 6)
            .store_slice(response_address)
            .store_coins(msg_value)
            .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
            .store_uint(op::excesses(), 32)
            .store_uint(query_id, 64);
        send_raw_message(msg.end_cell(), 2);
    }
    
    save_data(balance + jetton_amount, owner_address, jetton_master_address, jetton_wallet_code);
}

() burn_tokens(slice in_msg_body, slice sender_address, int msg_value, int fwd_fee) impure {
    ;; NOTE we can not allow fails in action phase since in that case there will be
    ;; no bounce. Wallet owner will not be notified that burn is failed.
    ;; On the other hand, we can not simply burn tokens because that would be convenient way to attack (wallet will burn tokens, will try to send notification, will fail, and the tokens will be lost).
    ;; In that case, we do not burn tokens at all, and will bounce them back if we can not send the notification.
    
    int query_id = in_msg_body~load_uint(64);
    int jetton_amount = in_msg_body~load_coins();
    slice response_address = in_msg_body~load_msg_addr();
    
    ;; Optional custom payload
    cell custom_payload = null();
    if (in_msg_body.slice_bits() > 0) {
        custom_payload = in_msg_body~load_dict();
    }
    
    (int balance, slice owner_address, slice jetton_master_address, cell jetton_wallet_code) = load_data();
    
    balance -= jetton_amount;
    
    throw_unless(705, equal_slices(owner_address, sender_address));
    throw_unless(706, balance >= 0);
    throw_unless(707, msg_value > fwd_fee + 2 * 10000000);
    
    var msg_body = begin_cell()
        .store_uint(op::burn_notification(), 32)
        .store_uint(query_id, 64)
        .store_coins(jetton_amount)
        .store_slice(owner_address)
        .store_slice(response_address)
        .end_cell();
    
    var msg = begin_cell()
        .store_uint(0x18, 6)
        .store_slice(jetton_master_address)
        .store_coins(0)
        .store_uint(1, 1 + 4 + 4 + 64 + 32 + 1 + 1)
        .store_ref(msg_body);
    
    send_raw_message(msg.end_cell(), 64);
    
    save_data(balance, owner_address, jetton_master_address, jetton_wallet_code);
}

() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
    if (in_msg_body.slice_empty?()) { ;; ignore empty messages
        return ();
    }
    
    slice cs = in_msg_full.begin_parse();
    int flags = cs~load_uint(4);
    
    if (flags & 1) { ;; ignore all bounced messages
        return ();
    }
    
    slice sender_address = cs~load_msg_addr();
    cs~load_msg_addr(); ;; skip dst
    cs~load_coins(); ;; skip value
    cs~skip_bits(1); ;; skip extracurrency collection
    cs~load_coins(); ;; skip ihr_fee
    int fwd_fee = cs~load_coins(); ;; we use message fwd_fee for estimation of forward_payload costs
    
    int op = in_msg_body~load_uint(32);
    
    if (op == op::transfer()) { ;; outgoing transfer
        send_tokens(in_msg_body, sender_address, msg_value, fwd_fee);
        return ();
    }
    
    if (op == op::internal_transfer()) { ;; incoming transfer
        receive_tokens(in_msg_body, sender_address, my_balance, fwd_fee, msg_value);
        return ();
    }
    
    if (op == op::burn()) { ;; burn
        burn_tokens(in_msg_body, sender_address, msg_value, fwd_fee);
        return ();
    }
    
    throw(0xffff);
}

cell calculate_jetton_wallet_state_init(slice owner_address, slice jetton_master_address, cell jetton_wallet_code) inline {
    return begin_cell()
        .store_uint(0, 2)
        .store_dict(jetton_wallet_code)
        .store_dict(pack_jetton_wallet_data(0, owner_address, jetton_master_address, jetton_wallet_code))
        .store_uint(0, 1)
        .end_cell();
}

slice calculate_jetton_wallet_address(cell state_init) inline {
    return begin_cell()
        .store_uint(4, 3)
        .store_int(workchain(), 8)
        .store_uint(cell_hash(state_init), 256)
        .end_cell()
        .begin_parse();
}

slice calculate_user_jetton_wallet_address(slice owner_address, slice jetton_master_address, cell jetton_wallet_code) inline {
    return calculate_jetton_wallet_address(calculate_jetton_wallet_state_init(owner_address, jetton_master_address, jetton_wallet_code));
}

cell pack_jetton_wallet_data(int balance, slice owner_address, slice jetton_master_address, cell jetton_wallet_code) inline {
    return begin_cell()
        .store_coins(balance)
        .store_slice(owner_address)
        .store_slice(jetton_master_address)
        .store_ref(jetton_wallet_code)
        .end_cell();
}

;; Get methods

(int, slice, slice, cell) get_wallet_data() method_id {
    return load_data();
}
